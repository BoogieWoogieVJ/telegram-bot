import json
import logging
from typing import Dict, List, Optional

from openai import AsyncOpenAI

logger = logging.getLogger(__name__)


# ==============================================
#   Инициализация OpenAI API
# ==============================================

client: Optional[AsyncOpenAI] = None

def init_openai(api_key: str) -> None:
    """
    Инициализирует OpenAI API ключ.
    Вызывается один раз при запуске бота.
    """
    global client
    client = AsyncOpenAI(api_key=api_key)
    logger.info("✅ OpenAI API инициализирован")


# ==============================================
#   Список категорий по умолчанию
# ==============================================

DEFAULT_CATEGORIES = {
    "🛒 Покупки",
    "💡 Идеи",
    "🍳 Рецепты",
    "🎬 Фильмы",
    "📚 Книги",
    "🎵 Музыка",
    "🎯 Прочее",
}


# ==============================================
#   Получение доступных категорий
# ==============================================

async def get_available_categories(user_categories: Optional[List[str]] = None) -> List[str]:
    """
    Объединяет категории по умолчанию с существующими категориями пользователя.
    ИИ будет выбирать из этого списка или создавать новую.
    
    Args:
        user_categories: список уже использованных категорий пользователем (или None)
    
    Returns:
        отсортированный список всех доступных категорий
    """
    all_categories = DEFAULT_CATEGORIES.copy()
    
    if user_categories:
        valid_categories = [cat for cat in user_categories if cat is not None]
        all_categories.update(set(valid_categories))
    
    return sorted(list(all_categories))


# ==============================================
#   Основная функция анализа заметки
# ==============================================

async def analyze_note(
    text: str, 
    user_categories: Optional[List[str]] = None
) -> Dict[str, str]:
    """
    Анализирует заметку через OpenAI API.
    Определяет категорию и генерирует развёрнутое описание.
    
    ВАЖНО: 
    - Сохраняет исходный текст как есть
    - Определяет категорию (может быть существующей или новой)
    - Генерирует описание с контекстом, пояснениями и рекомендациями
    
    Args:
        text: текст заметки от пользователя (может быть с ошибками, в спешке и т.д.)
        user_categories: существующие категории пользователя (для контекста)
    
    Returns:
        dict:
        {
            "category": "🛒 Покупки",  # существующая или новая
            "description": "Молочные продукты и хлеб. Можно приготовить..."
        }
    """
    
    available_categories = await get_available_categories(user_categories)
    categories_str = "\n".join(available_categories)
    
    # ════════════════════════════════════════════════════════════
    # Формируем промпт для OpenAI
    # ════════════════════════════════════════════════════════════
    
    prompt = f"""Ты помощник для управления личными заметками. Люди часто вводят заметки в спешке, 
с опечатками, сокращениями, аббревиатурами. Твоя задача помочь им понять, что они имели в виду.
Пиши максимально кратко. 1–2 предложения, ≤ 160–220 символов.
Не повторяй текст пользователя (запрещены конструкции «Пользователь планирует…», «В заметке говорится…»).
Запрещена энциклопедичность (без общих фактов, определений, «полезных свойств» и пересказов сюжета).
Добавляй только практическую пользу (что сделать/что учесть/чего не забыть).

КРИТИЧЕСКИ ВАЖНО: Ты ДОЛЖЕН интерпретировать контекст и расшифровывать аббревиатуры/сокращения.
Примеры расшифровок:
- "Adobe fairfly" или "адоб файрфлай" → Adobe Firefly - генератор изображений от Adobe
- "V0" или "V0 io" → v0.dev - AI платформа для генерации кода React+TailwindCSS от Vercel
- "Перплексити" → Perplexity - AI поисковик и аналитический сервис
- "GPT" → ChatGPT или просто GPT - языковая модель от OpenAI
- "Claude" → Claude - языковая модель от Anthropic
- "Тетрадь смерти" → Death Note - японское аниме о сверхспособностях
- "Монолог фармацевта" → аниме, основанное на визуальном романе

Пиши максимально кратко. 1–2 предложения, ≤ 220 символов.
Не повторяй текст пользователя (запрещены «Пользователь планирует…», «В заметке говорится…»).
Запрещена энциклопедичность: не указывай «полезные свойства», определения, биографии, синопсисы.
Дай только практическую пользу: что сделать/учесть/не забыть.


═══════════════════════════════════════════════════════════════
СУЩЕСТВУЮЩИЕ КАТЕГОРИИ ПОЛЬЗОВАТЕЛЯ:
═══════════════════════════════════════════════════════════════
{categories_str}

═══════════════════════════════════════════════════════════════
ПРАВИЛА ДЛЯ КАТЕГОРИЙ:
═══════════════════════════════════════════════════════════════
1. Если текст явно подходит под существующую категорию — выбери её.
2. Если текст НЕ подходит ни под одну существующую категорию — СОЗДАЙ новую категорию сам!
   Примеры новых категорий: "🎮 Игры", "🤖 ИИ Инструменты", "📺 Аниме", "✈️ Путешествия", "🛠️ Программирование"
3. НИКОГДА не предлагай создавать новую категорию! Просто СОЗДАЙ её!
4. Используй "🎯 Прочее" только если категория совершенно неопределима.

═══════════════════════════════════════════════════════════════
ЗАДАЧА ОПИСАНИЯ:
═══════════════════════════════════════════════════════════════
Описание должно:
- Расшифровывай аббревиатуры только если без этого смысл может исказиться.
- Формулируй суть действия/намерения в одном коротком предложении.
- Адаптация к категории — без справок и определений. Только практичная подсказка.

- Адаптироваться к категории:

  🛒 Для "🛒 Покупки": предложи дополнения к продуктам и блюда, которые можно приготовить. не пиши про свойства продуктов; 1 полезное дополнение к списку «если нужно» (напр. «добавь пармезан/масло»).
  💡 Для "💡 Идеи": развей идею, добавь практических деталей
  🍳 Для "🍳 Рецепты": предложи альтернативные ингредиенты и способы приготовления
  🎬 Для "🎬 Медиа: не писать синопсис. Коротко: «добавить в список к просмотру; жанр: … (если уверен)».
  📚 Для "📚 Книги": что это за книга, автор, о чём
  🎵 Для "🎵 Музыка": исполнитель, жанр, когда и где слушать
  🤖 Для "🤖 ИИ Инструменты": расшифруй что это за сервис/инструмент, его возможности. 1 фраза «что это» + зачем оно тебе (контекстно).
  🎮 Для "🎮 Игры": название игры, жанр, платформа
  Для других категорий: полезное пояснение с расшифровкой аббревиатур. 1 практический шаг («уточни дату встречи», «проверь версию CLI» и т.д.)

═══════════════════════════════════════════════════════════════
ЗАМЕТКА ПОЛЬЗОВАТЕЛЯ: "{text}"
═══════════════════════════════════════════════════════════════

Вернись ТОЛЬКО валидным JSON, без дополнительного текста:

{{
    "category": "выбранная или НОВАЯ категория с эмодзи",
    "description": "1–2 очень коротких предложения (≤ 220 символов). Без повторов, без определений, только практическая польза."
}}"""

    try:
        logger.info(f"🤖 Анализирую заметку: '{text}'")
        
        # ════════════════════════════════════════════════════════════
        # Вызываем OpenAI API (новый синтаксис)
        # ════════════════════════════════════════════════════════════
        
        if client is None:
            raise RuntimeError("OpenAI client не инициализирован. Вызови init_openai() первым.")
        
        response = await client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": (
                        "Ты помощник для анализа заметок. "
                        "Отвечай ТОЛЬКО валидным JSON, без дополнительного текста. "
                        "Будь точен и внимателен при определении категорий и расшифровке аббревиатур."
                    )
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.3,
            max_tokens=200,
            top_p=0.9
        )
        
        # ════════════════════════════════════════════════════════════
        # Парсим ответ
        # ════════════════════════════════════════════════════════════
        
        response_text = response.choices[0].message.content.strip()
        result = json.loads(response_text)
        
        category = result.get("category", "🎯 Прочее").strip()
        description = result.get("description", "").strip()
        
        logger.info(f"✅ Анализ готов: {category}")
        
        return {
            "category": category,
            "description": description
        }
        
    except json.JSONDecodeError as e:
        logger.error(f"❌ ИИ вернул невалидный JSON: {e}")
        logger.error(f"   Ответ был: {response_text if 'response_text' in locals() else 'N/A'}")
        
        # Fallback: вернём категорию по умолчанию
        return {
            "category": "🎯 Прочее",
            "description": "Ошибка при анализе. Заметка сохранена, но описание не создано."
        }
        
    except Exception as e:
        logger.error(f"❌ Ошибка при вызове OpenAI API: {e}", exc_info=True)
        
        # Fallback: если API недоступен
        return {
            "category": "🎯 Прочее",
            "description": f"API недоступен: {str(e)}"
        }


# ==============================================
#   Хелпер для проверки валидности категории
# ==============================================

def is_valid_category(category: str) -> bool:
    """
    Проверяет, что категория имеет правильный формат.
    Формат: "ЭМОДЗИ название" (например "🛒 Покупки")
    
    Args:
        category: строка для проверки
    
    Returns:
        True если категория валидна, False иначе
    """
    # Проверяем, что есть пробел и что часть после пробела не пустая
    if not category or " " not in category:
        return False
    
    parts = category.split(" ", 1)
    emoji_part = parts[0]
    name_part = parts[1] if len(parts) > 1 else ""
    
    # Простая проверка: первый символ не ASCII буква/цифра (вероятно эмодзи)
    # и есть название
    return len(emoji_part) > 0 and len(name_part) > 0


# ==============================================
#   Получение рекомендуемых категорий
# ==============================================

async def get_suggested_categories(text: str) -> List[str]:
    """
    Быстро предлагает несколько подходящих категорий на основе текста.
    Может использоваться для UI подсказок (но не для сохранения).
    
    Args:
        text: текст заметки
    
    Returns:
        список из 2-3 предложенных категорий
    """
    # Простая эвристика для быстрого определения
    text_lower = text.lower()
    
    suggestions = []
    
    if any(word in text_lower for word in ["купи", "куп", "магаз", "продукт", "хлеб", "молок", "молоко"]):
        suggestions.append("🛒 Покупки")
    
    if any(word in text_lower for word in ["идея", "думаю", "может", "хочу", "создать", "написать"]):
        suggestions.append("💡 Идеи")
    
    if any(word in text_lower for word in ["рецепт", "готовить", "блюдо", "приготов", "ингредиент"]):
        suggestions.append("🍳 Рецепты")
    
    if any(word in text_lower for word in ["фильм", "кино", "сериал", "посмотр", "видео"]):
        suggestions.append("🎬 Фильмы")
    
    if any(word in text_lower for word in ["книг", "читать", "прочит", "автор", "произведени"]):
        suggestions.append("📚 Книги")
    
    if any(word in text_lower for word in ["музык", "песн", "трек", "артист", "альбом", "композитор"]):
        suggestions.append("🎵 Музыка")
    
    if any(word in text_lower for word in ["аниме", "манга", "серия", "эпизод"]):
        suggestions.append("📺 Аниме")
    
    # Если ничего не подошло или меньше 1 — добавим Прочее
    if not suggestions:
        suggestions.append("🎯 Прочее")
    
    return suggestions[:3]  # Максимум 3 предложения